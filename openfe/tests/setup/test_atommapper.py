import pytest

from openfe.setup.atommapper import AtomMapper, ScoredAtomMapper

# These mix-in classes are used to create partially-concrete subclasses of
# ScoredAtomMapper.


class _MappingsInit:
    """Mix-in class to provide the __init__ for test subclasses"""
    def __init__(self, mappings):
        super().__init__()
        self.mappings = mappings


class _MappingsGenerator(_MappingsInit):
    """Mix-in class to provide the _mappings_generator method for tests"""
    def _mappings_generator(self, mol1, mol2):
        return (mapping for mapping in self.mappings)


class _CalculateScore:
    """Mix-in class to provide the _calculate_score method for tests"""
    def _calculate_score(self, atommapping):
        # score is the largest index of atoms retained by the mapping (yeah,
        # it's not intended to be a realistic score)
        return float(max(atommapping.mol1_to_mol2))


class TestAtomMapper:
    def test_abstract_error(self, simple_mapping):
        # suggest_mappings should fail with NotImplementedError if the user
        # tries to directly user the abstract class
        mol1 = simple_mapping.mol1
        mol2 = simple_mapping.mol2
        mapper = AtomMapper()
        match_re = "'AtomMapper'.*abstract.*_mappings_generator"
        with pytest.raises(NotImplementedError, match=match_re):
            list(mapper.suggest_mappings(mol1, mol2))

    def test_concrete_mapper(self, simple_mapping, other_mapping):
        # a correctly implemented concrete atom mapping should return the
        # mappings generated by the _mappings_generator
        mol1 = simple_mapping.mol1
        mol2 = simple_mapping.mol2

        class ConcreteAtomMapper(_MappingsGenerator, AtomMapper):
            pass

        mapper = ConcreteAtomMapper([simple_mapping, other_mapping])
        results = list(mapper.suggest_mappings(mol1, mol2))
        assert len(results) == 2
        assert results == [simple_mapping, other_mapping]


class TestScoredAtomMapper:
    @staticmethod
    def _create_instance_from_mixins(mixins, mappings):
        # if we have mixins, we require that we provide an __init__ that
        # takes the mappings; but also test something more like the bare
        # class
        args = [mappings] if mixins else []

        class Mapper(*mixins, ScoredAtomMapper):
            pass

        return Mapper(*args)

    @pytest.mark.parametrize('mixins', [
        [],
        [_MappingsInit],
        [_MappingsGenerator],
        [_CalculateScore, _MappingsInit],
    ])
    def test_suggest_mappings_abstract_error(self, mixins, simple_mapping,
                                             other_mapping):
        # suggest_mappings should fail with NotImplementedError when the
        # subclass has not implemented both of _calculate_score and
        # _mappings_generator.
        mol1, mol2 = simple_mapping.mol1, simple_mapping.mol2
        mapper = self._create_instance_from_mixins(mixins, [simple_mapping,
                                                            other_mapping])

        # if _mappings_generator exists, then the function that causes the
        # error is _calculate_score; otherwise it is _mappings_generator
        if _MappingsGenerator in mixins:
            missing_func = '_calculate_score'
        else:
            missing_func = '_mappings_generator'

        match_re = f"'Mapper'.*abstract.*{missing_func}"
        with pytest.raises(NotImplementedError, match=match_re):
            list(mapper.suggest_mappings(mol1, mol2))

    @pytest.mark.parametrize('mixins', [
        [],
        [_MappingsInit],
        [_MappingsGenerator],
    ])
    def test_score_abstract_error(self, mixins, simple_mapping,
                                  other_mapping):
        # score should fail with a NotImplementedError if _calculate_score
        # is not implemented
        mapper = self._create_instance_from_mixins(mixins, [simple_mapping,
                                                            other_mapping])

        match_re = "'Mapper'.*abstract.*_calculate_score"
        with pytest.raises(NotImplementedError, match=match_re):
            mapper.score(simple_mapping)

    def test_concrete_mappings(self, simple_mapping, other_mapping):
        # when the concrete class is correctly defined, suggest_mappings
        # should give us the expected mappings
        mol1 = simple_mapping.mol1
        mol2 = simple_mapping.mol2
        mapper = self._create_instance_from_mixins(
            mixins=[_MappingsGenerator, _CalculateScore],
            mappings=[simple_mapping, other_mapping]
        )
        results = list(mapper.suggest_mappings(mol1, mol2))
        assert len(results) == 2
        assert results == [simple_mapping, other_mapping]

    def test_concrete_score_cached(self, simple_mapping, other_mapping):
        # if the score has already been cached, calling score will get it
        # even without calling _calculate_score (tested by leaving that
        # unimplemented)
        mapper = self._create_instance_from_mixins(
            mixins=[_MappingsGenerator],
            mappings=[simple_mapping, other_mapping]
        )
        mapper._score_cache[simple_mapping] = 2.18
        result = mapper.score(simple_mapping)
        assert result.score == 2.18
        assert result.annotation == {}

    def test_concrete_score_not_cached(self, simple_mapping, other_mapping):
        # if the score has not been cached, calling score will get it by
        # calling _calculate_score
        mapper = self._create_instance_from_mixins(
            mixins=[_MappingsGenerator, _CalculateScore],
            mappings=[simple_mapping, other_mapping]
        )
        result = mapper.score(simple_mapping)
        assert result.annotation == {}
        assert result.score == 1.0
